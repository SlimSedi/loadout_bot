<script src="https://cdn.rawgit.com/oscarmorrison/md-page/c72eb9e9/md-page.js"></script><noscript>
# Loadout generator for Helldivers 2 - Discord bot
## [Video Demo: https://www.youtube.com/watch?v=i1rzwUheGdw](https://www.youtube.com/watch?v=i1rzwUheGdw)
## Project Overview
### Goal
This app is a discord bot for players of the game "Helldivers 2".  
This bot should provide the user a random, but **viable** loadout, based on the enemy faction and planetary conditions. The user should only be required to input the name of the planet that they want to play on.
  
### Requirements/Problems to solve
- Setting up a blank Discord bot.
- Creating a database with all loadout items in the game.
- Receive user input (Name of a planet).
- Query the Helldivers 2 API to check which enemy faction is present and what environmental hazard the planet might have.
- With those parameters in mind, generate a list of all viable items.
- Pick random items from the list to generate a **_viable_** loadout and send it back to the user.
  
A viable loadout consists of:
- One primary weapon
- One secondary weapon
- One grenade
- Four stratagems
  
A viable loadout needs to fulfill the following parameters:
- Each item must be viable against the enemy faction on the planet. (E.g. No flamethrower vs the robots)
- At **MAX** one item that occupies the backpack slot.
- At **MAX** one item that occupies the heavy weapon slot.
- At **LEAST** one item that can destroy enemy spawn locations (bug holes, factories or dropships).
- No heat based weaponry, if the planet is hot.
- A higher chance of heat based weaponry, if the planet is cold.

## About Discord
Discord is a chatting application used predominantly within gaming communities. Discord supports the creation of custom applications, like this project.

## About Helldivers 2
Helldivers 2 is a 3<sup>rd</sup> person PvE (co-op) shooter for up to four players. Players can choose a planet to fight on. Each player is then asked to assemble a loadout for the mission. Each planet has one of three possible hostile factions present. Which faction is present is the **main** consideration for selecting a loadout. Each player can carry one backpack and one heavy weapon, so having more than one of those items in a loadout is very wasteful. On most missions, players will come across "enemy spawners" which can only be destroyed by certain weapons or stratagems. A player should always have at least one of those items in their loadout. Some weapons have worse performance on hot planets, but better performance on cold planets. A good loadout should take this into consideration.

# File explanations
## main.py
### initialization
By calling `load_dontenv(".env")`, the TOKEN variable is set to the value of TOKEN in the .env file.  
bot = `commands.Bot(...)` Sets up the parameters for interfacing with the user and assigns it to the bot variable.  
At the end of the code, `bot.run(TOKEN)` is called.

### commands
Commands are initialized with `@bot.command`, followed by defining a function with the name of the command.
#### hello
When a user inputs "!hello", "!hi" or "!servus", the bot returns an Austrian greeting, mentioning the user, who typed the command.
#### help
When a user inputs "!help" or "!h", the bot returns an explanation of how to use the loadout command.
#### loadout
This command listens for at least one argument, `arg` after the user types "!loadout" or "!l".

##### Checking for valid input and getting the hostile faction
The command tries to access a [Helldivers 2 API](#apis) that lists all **currently active** planets and their respective hostile faction, returning an error message if not possible.
Iterating through the list of planets, if a **planet["name"]** matches the user provided planet name (`arg`), get the **planet["faction"]** and **planet["index"]**.

##### Getting the relevant environmental conditions
Using the **planet["index"]**, access a [Helldivers 2 API](#apis) that lists **all planets in the game** and iterate through the corresponding **planet["environmentals"]**. 
If the planet has either **"Extreme Cold"** or **"Intense Heat"**, append it to a list called **envir[]**. It is possible for a planet to have both **"Extreme Cold"** and **"Intense Heat"** (day/night). In that case, both are added to the list.

##### Populate lists of weapons and stratagems that are viable against the enemy faction
Using the [`populate(...)`](#populate) function, the lists **primary[]**, **secondary[]**, **grenades[]** and **stratagems[]** are populated with **all** items that are **good vs the enemy faction**.  
Which item is considered good vs any given faction was decided by me and is listed in the [`traits.json`](json/weapons/traits.json) file as traits "13", "14" or "15": "!Good vs Terminids/Automatons/Illuminates".  

##### Populate the loadout list
Using the previously generated lists, a list called **loadout[]** is populated with:
- One primary weapon from **primary[]** by calling the [`get_primary()`](#get_primary) function.
- One secondary weapon from **secondary[]** by calling the [`get_secondary()`](#get_secondary) function.
- One grenade by picking a random item from the **grenades[]** list.
- Four stratagems from **stratagems[]** by calling the [`get_stratagem()`](#get_stratagem) function four times.

The logic for choosing which primary, secondary, and stratagem to pick is handled within the respective functions.

If none of the items within the **loadout[]** list has the **destructive** trait, wipe the **loadout[]** list and start over, beginning at [`get_primary()`](#get_primary).  
This ensures that at least one item in the loadout is capable of destroying enemy spawners.  
Which item is considered capable of destroying enemy spawners was decided by me and is listed in the [`traits.json`](json/weapons/traits.json) file as trait "18": "!Destructive".

##### Send the user the completed loadout
Call either [`short_loadout(ctx, arg, faction, loadout)`](#short_loadoutctx-arg-faction-loadout) or [`long_loadout(ctx, loadout)`](#long_loadoutctx-loadout), depending on user input.  
If `arg2` == "short", call the `short_loadout(ctx, arg, faction, loadout)` function, which sends the user the loadout as a single embedded message, formatted into a neat table without images.  
Else, call the `long_loadout(ctx, loadout)` function, which generates an embedded message for each item in the loadout, allowing for an image to be displayed for each item.

### functions
#### populate()
`populate(file_name: str, list: list, faction: str)` will open a **json file** and iterate through each item´s `traits` values.  
This function will then append any item to **list** that is considered **Good vs _faction_**.  
See [`traits.json`](json/weapons/traits.json) for more information.  
`populate(file_name: str, list: list, faction: str)` requires three arguments:  
- file_name: The name of (and path to) the json file that you want to open. (E.g. "json/weapons/primary.json")
- list: The name of the list that you want to append to. (E.g. primary)
- faction: The hostile faction on the planet (E.g. "Terminids")

For example `populate("json/weapons/primary.json", primary, "Terminids")` will open [**primary.json**](json/weapons/primary.json) and append any item where "13" is in that item´s `traits`, to a list called **primary**.  

*The json files are nested dictionaries.*  
For [primary.json](json/weapons/primary.json), [secondary.json](json/weapons/secondary.json), and [grenades.json](json/weapons/grenades.json) each item has an ID number as a key and a dictionary (containing name:, description:, traits:, etc...) as a value.  
`populate()` only appends the inner dictionary to **list**.  
For [stratagems.json](json/stratagems.json) each item has the stratagem´s name as a key and a dictionary (containing uses:, traits:, etc...) as a value. Note that there is no "name" key in the inner dictionary and it should not be appended like this.  
Instead, it should be appended like this:
```
list.append({"name": item_id, **item})  
```
This will create a new dictionary with "name" as a key and the item´s id (which is the name of the stratagem) as a value. **item adds the rest of the inner dictionary (containing uses:, traits:, etc...) to this new dictionary.  
This new dictionary is then appended to **list**.

#### get_primary()
`get_primary` is defined within the loadout command.  
Most of the function exists within a **while True** loop.  
A random integer from 0 to len(primary) - 1 is created and assigned to a variable called **random_primary**.  
**random_primary** will be used as an index for the primary[] list. So **primary[random_primary]** means a **random weapon** from the **primary[]** list.  
Before adding this weapon to the loadout, it will be checked for viability using following logic:
```
if 9 in primary[random_primary]["traits"] and len(envir) == 1 and "Intense Heat" in envir:
              continue
```
This checks if the **random weapon** is effected by heat and if the planet is hot. (Some planets can have both **"Extreme Cold"** and **"Intense Heat"**. In that case, the logic treats this planet as if it had neither).  
If the **random weapon** is effected by heat and the planet is hot, restart the while loop. This creates a new random integer and therefore a new **random weapon**.

```
if 9 not in primary[random_primary]["traits"] and len(envir) == 1 and "Extreme Cold" in envir:
              if counter != 1:
                  counter += 1
                  continue
```
This checks if the **random weapon** is **NOT** effected by heat and if the planet is cold.  
If this is the case, restart the while loop **ONCE** (tracked by the counter variable). This will increase the chance to get a heat based weapon on a cold planet.

If all checks are passed, append the **loadout[]** list with the **random weapon** and break out of the loop.

#### get_secondary()
`get_secondary` is defined within the loadout command.  
Most of the function exists within a **while True** loop.  
The logic works similarly to the [`get_primary`](#get_primary) function. There are, however two new cases in which another **random secondary weapon** is chosen:
```
if (9 in secondary[random_secondary]["traits"] and len(envir) == 1 and "Intense Heat" in envir) or \
              (5 in secondary[random_secondary]["fire_mode"] and loadout[0]["type"] == 2) or \
              (18 in secondary[random_secondary]["traits"] and 18 in loadout[0]["traits"]):
              continue
```
In addition to the environmental check, this check also **fails** (the loop restarts) if the **random secondary weapon** is a shotgun and the (already to the **loadout[]** list appended) **primary weapon** is also a shotgun,  
or if the **random secondary weapon** is capable of destroying enemy spawners and the **primary weapon** is also capable of destroying enemy spawners.  
This ensures that the primary and the secondary weapon don´t fulfill the same combat role.

#### get_stratagem()
`get_stratagem` is defined within the loadout command.  
Most of the function exists within a **while True** loop.  
The logic works similarly to the [`get_primary`](#get_primary) function. There are, however three new cases in which another **random stratagem** is chosen:
```
if (16 in item["traits"] and 16 in stratagems[random_stratagem]["traits"]) or \
              (17 in item["traits"] and 17 in stratagems[random_stratagem]["traits"]) or \
              (item["name"] == stratagems[random_stratagem]["name"]):
                  conflict = True
                  break
```
In addition to the environmental check, this check also **fails** (the loop restarts) if the **random stratagem** is a backpack and any item in **loadout[]** is also a backpack,  
or if the **random stratagem** is a heavy weapon and any item in **loadout[]** is also a heavy weapon,  
or if the name of the **random stratagem** already exists within **loadout[]**.  
This ensures that the generated loadout will contain at max one backpack and one heavy weapon and that no stratagem is added twice.
Keep in mind that `get_stratagem` will be called four times in a row.

#### short_loadout(ctx, arg, faction, loadout)
`short_loadout(ctx, arg, faction, loadout)` creates one **Embed** with the title "Loadout", a short text containing the enemy **faction** on the planet with the name **arg**, and a thumbnail image called "freedom.gif".  
A **field** is created for each equipment slot. (primary, secondary, grenade,...)
The **loadout[]** list is then "unpacked" into the corresponding **fields**. Knowing that `get_primary()` was called first, **loadout[0]** is the the primary weapon, **loadout[1]** the secondary weapon,...  
A **footer** is created with an image called "pfp.png" and a short text, mentioning the user.

```
files = [
      discord.File("resources/freedom.gif", filename="freedom.gif"),
      discord.File("resources/pfp.png", filename="pfp.png")
  ]
```
In the **files** list are the names of (and paths to) the image files that are used in the embedded message.


`await ctx.send(embed=embeded_msg, files=files)` sends the embed as a message to the discord server.

#### long_loadout(ctx, loadout)
`long_loadout(ctx, loadout)` creates one **Embed** for each item in the **loadout[]** list and puts each **Embed** into a list called **embeds**.  
An empty list called **files[]** is also created. Each **embed** has an **image** attached to it. The **image** file name for each **embed** will be appended to the **files[]** list, using `discord.File()`.  
A list called **titles** is created containing ["Primary", "Secondary", "Grenade", "Stratagem 1", "Stratagem 2", "Stratagem 3", "Stratagem 4"].  

Each embed contains:
- A **title**, which is the name of the slot that a given item belongs to (E.g. "Primary")
- A **name**, which is the name of the weapon/stratagem (E.g. "AR-23 Liberator")
- An **image**, which is a **placeholder** for a PNG file from the resources folder. This **placeholder** corresponds to the name of the weapon/stratagem. (E.g. "attachment://AR-23Liberator.png")  
To assign an actual **image** to the **placeholder**, `discord.File(image_name, filename=placeholder)` is used. (E.g. `discord.File("resources/weapons/AR-23-Liberator.png", filename="AR-23Liberator.png")`)

Within `for i, item in enumerate(loadout)`:  
The **title** for each embed is created like this:
```
embeded_msg = discord.Embed(
          title=titles[i],
          color=discord.Color.red()
      )
```
The **name** for each embed is created like this:
```
embeded_msg.add_field(name=item["name"], value="", inline=False)
```
The **placeholder** for each embed is set like this:
```
embeded_msg.set_thumbnail(url=f"attachment://{item['name'].replace(' ', '-')}.png")
```
The names of the items in the **loadout[]** list have spaces, while the names of the PNG files use dashes instead. (E.g. value of the "name" key for an item in **loadout[]**: "AR-23 Liberator", Name of the corresponding PNG file in the resources folder: "AR-23-Liberator.png")  
That's why `embeded_msg.set_thumbnail(url=f"attachment://{item['name'].replace(' ', '-')}.png")` uses `.replace(' ', '-')` to replace all spaces from the name of the weapon to dashes.  
Then, the **placeholder** is simply set to "**name**.png"  

To assign an **image** to the **placeholder** and append it to the **files[]** list, this code is used:
```
file_name = f"resources/weapons/{item['name'].replace(' ', '-')}.png"
```
```
files.append(discord.File(file_name, filename=f"{item['name'].replace(' ', '-')}.png"))
```
Then, the embed is appended to the **embeds[]** list:
```
embeds.append(embeded_msg)
```
This code handles the creation of **embeds** for the **first three items** in **loadout[]** only. (Primary, Secondary and Grenades)  
Stratagems are handled differently because they have a different file path and a different naming convention for the PNG files.  
```
file_name = f"resources/stratagems/{item['name'].replace(' ', '_').replace('/', '_')}.png"
```
Spaces and slashes need to be replaced with "_".  

Once all seven **embeds** are created, (primary, secondary, grenade and 4 stratagems) a single message containing all **embeds** is sent to the user like this:
```
await ctx.send(embeds=embeds, files=files)
```

## .env
This file contains the token that has been generated by Discord and assigned to this bot.
## json/weapons folder
All json files were sourced from https://github.com/Stonemercy/Galactic-Wide-Web on GitHub  
The json files in this folder contain relevant information about every weapon in Helldivers 2.
### traits.json
[`traits.json`](json/weapons/traits.json)  

I have added the traits 13 - 18. This allows the loadout command logic to generate a loadout.
### primary/secondary/grenades.json
[primary.json](json/weapons/primary.json), [secondary.json](json/weapons/secondary.json), [grenades.json](json/weapons/grenades.json)  
I have added the appropriate traits to each weapon.
### json/stratagems.json
[stratagems.json](json/stratagems.json)  
I have added the appropriate traits to each stratagem.
## resources
All files in this folder were sourced from https://github.com/Stonemercy/Galactic-Wide-Web on GitHub.
## requirements
[requirements.txt](requirements.txt) lists the pip install commands I had to run for this app to work.


# Citations
## Youtube
### Setting up the Discord bot
https://www.youtube.com/watch?v=Eu7X2SUOpaI&list=PLwqYQaS6jxfmCUTbFU-_d5M4yGTmKS0gk&index=11
### Setting up commands
https://www.youtube.com/watch?v=5r6tpt3bZiY&list=PLwqYQaS6jxfmCUTbFU-_d5M4yGTmKS0gk&index=10
### Embedded messages
https://www.youtube.com/watch?v=YiOJw1RVsWM&list=PLwqYQaS6jxfmCUTbFU-_d5M4yGTmKS0gk&index=9
## GitHub
Every file **except for** .env, main.py, requirements.txt, and README.md has been sourced from https://github.com/Stonemercy/Galactic-Wide-Web
## APIs
### Active planets in Helldivers 2
https://helldiverstrainingmanual.com/api/v1/war/campaign  
This API returns a list of planets (and their parameters) that can be played on right now.
### All planets in Helldivers 2
https://helldiverstrainingmanual.com/api/v1/planets  
This API returns a list of all planets (and their parameters) that exist in Helldivers 2.
## ChatGPT
ChatGPT has been used for debugging and for answering general questions about python functions.  
I have used ChatGPT similarly to how I used CS50.ai throughout the course.#   l o a d o u t _ b o t 

 





